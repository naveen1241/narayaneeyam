<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nārāyaṇīyam Player — Go to & Transliteration</title>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Tiro+Devanagari+Hindi:wght@400;600&family=Noto+Serif+Devanagari:wght@400;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="icon" href="data:,">


<style>
:root{
  --primary: #3d8140;         /* default green theme primary */
  --primary-dark: #235026;
  --primary-light: #a4d4a6;
  --bg: #f2f8f3;
  --text: #143215;
  --ui-font: "Poppins", "Segoe UI", sans-serif;
  --deva-font: "Tiro Devanagari Hindi", "Noto Serif Devanagari", serif;
  --meaning-bg: rgba(255,255,255,0.94);
}

/* smooth transitions */
* { transition: background-color .22s ease, color .22s ease, border-color .22s ease, box-shadow .22s ease; box-sizing: border-box; }

/* page baseline */
body{ margin:0; padding:22px; font-family:var(--ui-font); background:var(--bg); color:var(--text); }

/* header */
h1{ text-align:center; color:var(--primary-dark); margin-bottom:12px; font-weight:600; }

/* config row */
#configRow{ display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap; margin-bottom:14px; }
.cfg-label{ font-size:0.95rem; color:var(--text); margin-right:6px; font-weight:600; }
select, .color-picker{ font-family: var(--ui-font); }

/* audio controls - single always-visible bar */
#audioControls{
  max-width:1100px; margin:0 auto 8px; display:flex; flex-direction:column; gap:8px;
  padding:12px; border:3px solid var(--primary-dark); border-radius:14px;
  background: linear-gradient(180deg, var(--primary-light) 0%, var(--bg) 100%);
  box-shadow:0 6px 18px rgba(0,0,0,0.06);
}

/* top row: actual buttons */
.control-row{
  display:flex; align-items:center; justify-content:center; gap:10px; flex-wrap:wrap;
}

/* second row: time + translit toggle + Go to on right */
.time-row{
  display:flex; align-items:center; justify-content:space-between; gap:12px; width:100%;
  border-top:2px solid var(--primary-dark); padding-top:10px;
}

/* left area inside time row (translit toggle + elapsed info) */
.time-left{ display:flex; align-items:center; gap:10px; }

/* right area: Go to */
.time-right{ display:flex; align-items:center; gap:8px; }

/* buttons */
button{
  background:var(--bg); border:2px solid var(--primary-dark); color:var(--primary-dark);
  border-radius:10px; padding:8px 12px; cursor:pointer; font-weight:600;
}
button:hover{ background:var(--primary-light); box-shadow:0 4px 10px rgba(0,0,0,0.06); }
button.icon-btn{ width:54px; height:44px; display:flex; align-items:center; justify-content:center; padding:0; font-size:1.05rem; }

/* prev/next with labels */
.btn-with-label{ display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:10px; }
.btn-label-small{ font-size:0.88rem; font-weight:600; color:var(--primary-dark); }

/* groups panel (Go to) - collapsed by default, expands downward */
#gotoWrapper{ position:relative; display:flex; align-items:center; }
#gotoToggle{ background:transparent; border:none; color:var(--primary-dark); font-weight:700; cursor:pointer; padding:6px 8px; }
#gotoPanel{
  position:absolute; right:0; top:34px; width:520px; max-width:calc(100vw - 44px);
  background:white; border:2px solid var(--primary-dark); border-radius:10px; padding:10px;
  box-shadow:0 12px 30px rgba(0,0,0,0.08); display:none; z-index:60;
}

/* group select grid */
.group-grid{ display:flex; flex-wrap:wrap; gap:8px; justify-content:center; }
.group-select{ border:2px solid var(--primary-dark); border-radius:8px; padding:8px 12px; font-weight:700; background:white; cursor:pointer; min-width:120px; text-align:center; }
.group-select:hover{ background:var(--primary-light); }

/* time display text */
#timeDisplay{ font-family:var(--ui-font); color:var(--primary-dark); font-weight:700; }

#currentInfo {
  font-family: var(--ui-font);
  color: var(--primary-dark);
  font-weight: 700;
  margin-right: 8px;
}


/* subtitle container */
#subtitleContainer{ max-width:1100px; margin:12px auto 0; padding:22px; border:3px dashed var(--primary-dark); border-radius:12px; background:white; box-shadow:0 8px 24px rgba(0,0,0,0.04); text-align:center; line-height:1.9; }
#verse, #splitWords{ font-family:var(--deva-font); letter-spacing:0.02em; line-height:1.9; text-align:center; }
#verse{ font-size:2.4rem; font-weight:700; color:var(--primary-dark); margin-bottom:14px; }
#splitWords{ font-size:1.45rem; font-style:italic; color:var(--primary); margin-bottom:12px; }
#meaning{ font-family:var(--ui-font); font-size:1.12rem; color:var(--primary-dark); max-width:960px; margin:0 auto; text-align:justify; line-height:1.8; background:var(--meaning-bg); padding:12px 14px; border-radius:10px; border:1px solid rgba(0,0,0,0.03); }

/* audio element */
audio{ display:block; margin:10px auto 0; width:100%; max-width:1100px; accent-color:var(--primary); }

/* responsive */
@media (max-width:820px){
  #verse{ font-size:1.8rem; } #splitWords{ font-size:1.1rem; } #meaning{ font-size:1rem; }
  .group-select{ min-width:100px; font-size:0.95rem; padding:7px 10px; }
  #gotoPanel{ width:calc(100vw - 32px); left:8px; right:8px; top:44px; }
}

</style>
</head>
<body>
<h1>Nārāyaṇīyam Player</h1>

<!-- top config row -->
<div id="configRow">
  <div id="themeSelectorContainer"><span class="cfg-label">Theme</span>
    <select id="themeSelect">
      <option value="green">Green</option>
      <option value="blue">Blue</option>
      <option value="brown">Brown</option>
      <option value="purple">Purple</option>
      <option value="teal">Teal</option>
      <option value="charcoal">Charcoal</option>
      <option value="maroon">Maroon</option>
      <option value="custom">Custom</option>
    </select>
  </div>

  <div id="fontSelectorContainer">
    <span class="cfg-label">UI Font</span>
    <select id="uiFontSelect">
      <option value='"Poppins", "Segoe UI", sans-serif'>Poppins</option>
      <option value='"Roboto", "Segoe UI", sans-serif'>Roboto</option>
      <option value='"Merriweather", serif'>Merriweather</option>
    </select>

    <span class="cfg-label">Devanagari Font</span>
    <select id="devaFontSelect">
      <option value='"Tiro Devanagari Hindi", serif' selected>Tiro Devanagari Hindi</option>
      <option value='"Noto Serif Devanagari", serif'>Noto Serif Devanagari</option>
      <option value='"Mukta Vaani", sans-serif'>Mukta Vaani</option>
    </select>
  </div>
</div>

<!-- audio controls - always visible -->
<div id="audioControls" aria-label="Audio controls">

  <!-- Main controls row -->
  <div class="control-row">
    <button id="prevDashakamBtn" class="btn-with-label"><i class="fas fa-step-backward"></i><span class="btn-label-small">Dashakam</span></button>
    <button id="prevVerseBtn" class="btn-with-label"><i class="fas fa-backward"></i><span class="btn-label-small">Verse</span></button>

    <button id="playPauseBtn" class="icon-btn"><i class="fas fa-play"></i></button>

    <button id="repeatVerseBtn" class="icon-btn" title="Repeat Verse"><i class="fas fa-redo"></i></button>
    <button id="repeatDashakamBtn" class="icon-btn" title="Repeat Dashakam"><i class="fas fa-infinity"></i></button>

    <button id="nextVerseBtn" class="btn-with-label"><span class="btn-label-small">Verse</span><i class="fas fa-forward"></i></button>
    <button id="nextDashakamBtn" class="btn-with-label"><span class="btn-label-small">Dashakam</span><i class="fas fa-step-forward"></i></button>

    <button id="speedBtn" class="icon-btn" title="Change Speed"><i class="fas fa-tachometer-alt"></i></button>
    <button id="muteBtn" class="icon-btn" title="Mute"><i class="fas fa-volume-up"></i></button>
  </div>

  <!-- Time + transliteration toggle + Go to -->
  <div class="time-row">
<div class="time-left">
  <button id="translitToggle">English Transliteration</button>
  <div id="currentInfo">Dashakam — Verse —</div>
  <div id="timeDisplay">Elapsed: 00:00 | Remaining: 00:00 | Total Elapsed: 00:00 | Total Remaining: 00:00</div>
</div>


    <div class="time-right">
      <div id="gotoWrapper">
        <button id="gotoToggle">Go to ▾</button>
        <div id="gotoPanel" aria-hidden="true">
          <div class="group-grid" id="groupGrid"><!-- groups injected here --></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- native audio element -->
<audio id="audio" preload="auto"></audio>

<!-- subtitles -->
<div id="subtitleContainer">
  <div id="verse"></div>
  <div id="splitWords"></div>
  <div id="meaning"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  /*** DOM references ***/
  const audio = document.getElementById('audio');
  const playPauseBtn = document.getElementById('playPauseBtn');
  const prevDashakamBtn = document.getElementById('prevDashakamBtn');
  const nextDashakamBtn = document.getElementById('nextDashakamBtn');
  const prevVerseBtn = document.getElementById('prevVerseBtn');
  const nextVerseBtn = document.getElementById('nextVerseBtn');
  const repeatVerseBtn = document.getElementById('repeatVerseBtn');
  const repeatDashakamBtn = document.getElementById('repeatDashakamBtn');
  const speedBtn = document.getElementById('speedBtn');
  const muteBtn = document.getElementById('muteBtn');
  const timeDisplay = document.getElementById('timeDisplay');
  const verseDiv = document.getElementById('verse');
  const splitWordsDiv = document.getElementById('splitWords');
  const meaningDiv = document.getElementById('meaning');
  const gotoToggle = document.getElementById('gotoToggle');
  const gotoPanel = document.getElementById('gotoPanel');
  const groupGrid = document.getElementById('groupGrid');
  const themeSelect = document.getElementById('themeSelect');
  const uiFontSelect = document.getElementById('uiFontSelect');
  const devaFontSelect = document.getElementById('devaFontSelect');
  const translitToggle = document.getElementById('translitToggle');

  /*** State ***/
  const totalDashakams = 100;
  const estimatedDashakamDuration = 300;
  let cues = [];
  let currentCueIndex = -1;
  let currentDashakam = 1;
  let repeatVerse = false;
  let repeatDashakam = false;
  let showTranslit = false;
  let speedOptions = [1, 1.25, 1.5, 2];
  let speedIndex = 0;
  let speedTimeout = null;

  // seek state flags
  let isSeeking = false;
  let lastSeekTarget = 0;

  /*** Helpers ***/
  const nl2br = s => (s ? s.replace(/\n/g, '<br>') : '');
  const isAscii = s => /^[\x00-\x7F\s.,'"()\-:;!?—–…0-9]+$/.test(s);

// Simple tracer to catch unexpected function triggers
function trace(label, extra = {}) {
  const time = new Date().toISOString().split('T')[1].split('.')[0];
  console.log(`🪶 TRACE [${time}] ${label}`, extra);
}



  function timeToSeconds(t) {
    if (!t) return 0;
    const p = t.split(':').map(Number);
    if (p.length === 3) return p[0] * 3600 + p[1] * 60 + p[2];
    if (p.length === 2) return p[0] * 60 + p[1];
    return p[0] || 0;
  }

  // display current Dashakam/verse (if a UI element exists)
  function updateCurrentInfo() {
    const infoEl = document.getElementById("currentInfo");
    if (!infoEl) return;
    const verseNum = (currentCueIndex === -1) ? '-' : (currentCueIndex + 1);
    infoEl.textContent = `Dashakam ${String(currentDashakam).padStart(3,'0')} — Verse ${verseNum}`;
  }

  /*** Cue parsing ***/
  function parseCueText(text) {
    const lines = (text||'').trim().split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const verseEndRegex = /॥\s*[०-९0-9]+\s*॥/;
    let verseLines = [], splitLines = [], asciiLines = [];
    let foundVerseEnd = false, foundMeaningStart = false;
    for (const line of lines) {
      if (!foundVerseEnd) {
        verseLines.push(line);
        if (verseEndRegex.test(line)) foundVerseEnd = true;
      } else if (!foundMeaningStart) {
        if (isAscii(line)) { foundMeaningStart = true; asciiLines.push(line); }
        else splitLines.push(line);
      } else {
        asciiLines.push(line);
      }
    }
    const verseDev = verseLines.join('\n');
    const splitDev = splitLines.join('\n');
    const verseTrans = asciiLines.join('\n') || verseDev;
    const splitTrans = asciiLines.join('\n') || splitDev;
    const meaning = asciiLines.join('\n') || '';
    return { verseDev, splitDev, verseTrans, splitTrans, meaning };
  }

  /*** VTT loader ***/
  async function loadVTT(url) {
    try {
      const txt = await fetch(url).then(r => r.ok ? r.text() : '');
      if (!txt) return [];
      const lines = txt.split(/\r?\n/);
      const out = [];
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes('-->')) {
          const [start, end] = lines[i].split('-->');
          let textLines = [];
          i++;
          while (i < lines.length && lines[i].trim() !== '') {
            textLines.push(lines[i]);
            i++;
          }
          out.push({ start: (start||'').trim(), end: (end||'').trim(), text: textLines.join('\n') });
        }
      }
      return out;
    } catch (e) {
      console.warn('loadVTT error', e);
      return [];
    }
  }

  /*** Subtitle update (UI only) ***/
  function updateSubtitle(index) {
    if (!cues || index < 0 || index >= cues.length) return;
    currentCueIndex = index;
    const parsed = parseCueText(cues[index].text);
    verseDiv.innerHTML = nl2br(showTranslit ? parsed.verseTrans : parsed.verseDev);
    splitWordsDiv.innerHTML = nl2br(showTranslit ? parsed.splitTrans : parsed.splitDev);
    meaningDiv.innerHTML = nl2br(parsed.meaning || '');
  }

  /*** Minimal group grid + highlight (to avoid undefined errors) ***/
  function buildGroupGrid() {
    if (!groupGrid) return;
    groupGrid.innerHTML = '';
    for (let g = 0; g < 10; g++) {
      const start = g * 10 + 1, end = start + 9;
      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex';
      wrapper.style.flexDirection = 'column';
      wrapper.style.gap = '6px';
      wrapper.style.alignItems = 'center';
      const title = document.createElement('div');
      title.textContent = `${start}–${end}`;
      title.style.fontWeight = '700';
      wrapper.appendChild(title);
      const mini = document.createElement('div');
      mini.style.display = 'flex';
      mini.style.flexWrap = 'wrap';
      mini.style.gap = '6px';
      mini.style.justifyContent = 'center';
      for (let i = start; i <= end; i++) {
        const btn = document.createElement('button');
        btn.className = 'group-select';
        btn.textContent = i;
        btn.dataset.val = i.toString().padStart(3, '0');
        btn.addEventListener('click', ev => {
          loadDashakam(ev.currentTarget.dataset.val);
          openGoto(false);
        });
        mini.appendChild(btn);
      }
      wrapper.appendChild(mini);
      groupGrid.appendChild(wrapper);
    }
  }
  function highlightGoTo() {
    if (!groupGrid) return;
    groupGrid.querySelectorAll('.group-select').forEach(b => (b.style.background = 'white'));
    const sel = groupGrid.querySelector(`.group-select[data-val="${String(currentDashakam).padStart(3,'0')}"]`);
    if (sel) sel.style.background = getComputedStyle(document.documentElement).getPropertyValue('--primary-light') || '#a4d4a6';
  }

 /*** Load Dashakam (wait for metadata/canplay, load vtt) ***/
async function loadDashakam(val, autoPlay = false) {
  console.log("Loading Dashakam:", val, "autoPlay =", autoPlay);

  cues = [];
  currentCueIndex = -1;
  verseDiv.innerHTML = splitWordsDiv.innerHTML = meaningDiv.innerHTML = "";

  currentDashakam = parseInt(val, 10);

  // Stop and set up new audio
  audio.pause();
  audio.src = `audio/Narayaneeyam_D${val}.mp3`;
  audio.preload = "auto";
  audio.load();

  // ✅ Wait for metadata/duration to be available
await new Promise((resolve) => {
  let resolved = false;

  const checkReady = () => {
    if (resolved) return;
    if (audio.readyState >= 2 && audio.duration && audio.duration > 0) {
      resolved = true;
      cleanup();
      console.log(`Dashakam ${val} ready with duration=${audio.duration.toFixed(2)}s`);
      resolve();
    }
  };

  const cleanup = () => {
    clearInterval(check);
    clearTimeout(timeout);
    audio.removeEventListener("loadedmetadata", checkReady);
    audio.removeEventListener("canplay", checkReady);
  };

  const check = setInterval(checkReady, 100);
  const timeout = setTimeout(() => {
    if (!resolved) {
      console.warn(`Dashakam ${val} load timeout fallback (duration=${audio.duration || 0})`);
      resolved = true;
      cleanup();
      resolve();
    }
  }, 3000);

  audio.addEventListener("loadedmetadata", checkReady);
  audio.addEventListener("canplay", checkReady);
});


  // ✅ Load VTT cues
  cues = (await loadVTT(`vtt_fixed_output/Narayaneeyam_D${val}.vtt`)) || [];

  if (cues.length > 0) updateSubtitle(0);
  highlightGoTo();
  updateCurrentInfo();

  // Reset play icon
  playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';

  // ✅ Auto-play if requested
  if (autoPlay) {
    try {
      await audio.play();
      playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
    } catch (e) {
      console.warn("autoplay failed", e);
    }
  }

  console.log(
    `Dashakam ${val} ready (readyState=${audio.readyState}). cues=${cues.length}`
  );
}


  /*** Jump to cue — robust seek with retries and clear timeupdate suppression ***/
  async function jumpToCue(index, keepPlaying = true) {
    if (!cues || !cues[index]) return;
    const cue = cues[index];
    const target = timeToSeconds(cue.start);
    console.log('jumpToCue: moving to cue', index, 'time=', target.toFixed(3));

    isSeeking = true;
    lastSeekTarget = target;

    // ensure metadata/canplay
    if (audio.readyState < 1) {
      await new Promise(resolve => {
        audio.addEventListener('loadedmetadata', () => resolve(), { once: true });
        // small timeout fallback
        setTimeout(() => resolve(), 800);
      });
    }

    const maxAttempts = 5;
    let attempt = 0;
    let success = false;

    while (attempt < maxAttempts && !success) {
      attempt++;
      // perform seek
      try {
        audio.currentTime = target;
      } catch (e) {
        // some browsers may throw if not ready; ignore and continue
        console.warn('jumpToCue: set currentTime error', e);
      }

      // wait for seeked event (or timeout)
      await new Promise(resolve => {
        let resolved = false;
        const onSeeked = () => {
          if (resolved) return;
          resolved = true;
          audio.removeEventListener('seeked', onSeeked);
          resolve();
        };
        audio.addEventListener('seeked', onSeeked, { once: true });
        // fallback timeout if seeked doesn't fire quickly
        setTimeout(() => {
          if (!resolved) {
            resolved = true;
            audio.removeEventListener('seeked', onSeeked);
            resolve();
          }
        }, 400);
      });

      // check how close we are to target
      const diff = Math.abs(audio.currentTime - target);
      console.log(`jumpToCue: attempt #${attempt} currentTime=${audio.currentTime.toFixed(3)} diff=${diff.toFixed(3)}`);
      if (diff <= 0.35) {
        success = true;
        break;
      } else {
        // small delay before retrying
        await new Promise(r => setTimeout(r, 120));
      }
    }

    // finalize UI state regardless of absolute success
    currentCueIndex = index;
    const parts = parseCueText(cue.text);
    verseDiv.innerHTML = nl2br(showTranslit ? parts.verseTrans : parts.verseDev);
    splitWordsDiv.innerHTML = nl2br(showTranslit ? parts.splitTrans : parts.splitDev);
    meaningDiv.innerHTML = nl2br(parts.meaning || '');
    updateCurrentInfo();

    // resume play if requested
    if (keepPlaying) {
      try {
        await audio.play();
      } catch (e) {
        console.warn('jumpToCue: play failed after seek', e);
      }
    }

    // allow timeupdate to resume mapping cues
    setTimeout(() => {
      isSeeking = false;
      // set lastSeekTarget a small delay so timeupdate ignores tiny immediate jumps
      setTimeout(() => { lastSeekTarget = 0; }, 300);
    }, 250);

    console.log('jumpToCue: finished (success=' + success + ') currentTime=' + audio.currentTime.toFixed(3));
  }

  /*** Cue index helper (map time to cue) ***/
  function getCueIndexAtTime(nowSec = audio.currentTime) {
    if (!cues || cues.length === 0) return -1;
    for (let i = 0; i < cues.length; i++) {
      const s = timeToSeconds(cues[i].start);
      const e = timeToSeconds(cues[i].end);
      if (nowSec >= s && nowSec < e) return i;
    }
    const idx = cues.findIndex(c => timeToSeconds(c.start) > nowSec);
    return idx > 0 ? idx - 1 : 0;
  }

  /*** Timeupdate handler ***/
  audio.addEventListener('timeupdate', () => {
    if (isSeeking || !cues || cues.length === 0) return;
    const now = audio.currentTime;
    // ignore if we've just sought very close to last target
    if (lastSeekTarget && Math.abs(now - lastSeekTarget) < 0.35) return;
    const idx = getCueIndexAtTime(now);
    if (idx !== currentCueIndex) {
      // update subtitle (UI only)
      updateSubtitle(idx);
      updateCurrentInfo();
      // don't force audio.currentTime here
    }
    // update time text
    const elapsed = now || 0;
    const duration = (audio.duration && !isNaN(audio.duration)) ? audio.duration : estimatedDashakamDuration;
    const remaining = Math.max(0, duration - elapsed);
    timeDisplay.textContent = `Elapsed: ${formatTime(elapsed)} | Remaining: ${formatTime(remaining)}`;
  });

  /*** Prev / Next Verse handlers ***/
  prevVerseBtn.addEventListener('click', async () => {
    if (!cues || cues.length === 0) return;
    let idx = currentCueIndex !== -1 ? currentCueIndex : getCueIndexAtTime();
    console.log(`prevVerse clicked, currentCueIndex=${currentCueIndex}, computedIdx=${idx}`);
    if (idx > 0) {
      await jumpToCue(idx - 1);
      return;
    }
    if (currentDashakam > 1) {
      const prevD = String(currentDashakam - 1).padStart(3, '0');
      const wasPlaying = !audio.paused && !audio.ended;
      await loadDashakam(prevD, wasPlaying);
      if (cues.length > 0) await jumpToCue(cues.length - 1, wasPlaying);
    } else if (repeatDashakam && cues.length > 0) {
      await jumpToCue(cues.length - 1);
    }
  });

  nextVerseBtn.addEventListener('click', async () => {
  trace('nextVerseBtn.click', { currentCueIndex, audioTime: audio.currentTime.toFixed(3) });

  if (!cues || cues.length === 0) return;

  let idx = currentCueIndex !== -1 ? currentCueIndex : getCueIndexAtTime();
  console.log(`➡️ nextVerse clicked, currentCueIndex=${currentCueIndex}, computedIdx=${idx}`);

  if (idx < cues.length - 1) {
    // ensure can seek quickly
    if (audio.readyState < 2) {
      await new Promise(resolve => {
        const onCan = () => { audio.removeEventListener('canplay', onCan); resolve(); };
        audio.addEventListener('canplay', onCan);
        setTimeout(resolve, 700); // fallback
      });
    }

    // small delay and then jump
    console.log(`⏭️ nextVerse: moving to next cue ${idx + 1}`);
    setTimeout(() => jumpToCue(idx + 1, true), 150);
    return;
  }

  // move to next dashakam
  if (currentDashakam < totalDashakams) {
    const nextD = String(currentDashakam + 1).padStart(3, '0');
    const wasPlaying = !audio.paused && !audio.ended;
    console.log(`➡️ nextVerse: end of dashakam ${currentDashakam}, loading ${nextD}`);
    await loadDashakam(nextD, wasPlaying);

    if (cues.length > 0) {
      setTimeout(() => jumpToCue(0, wasPlaying), 250);
    }
  } else if (repeatDashakam && cues.length > 0) {
    console.log(`🔁 Repeating Dashakam`);
    jumpToCue(0);
  }
});


  /*** Prev/Next Dashakam UI buttons ***/
  prevDashakamBtn.addEventListener('click', () => {
    if (currentDashakam > 1) loadDashakam(String(currentDashakam - 1).padStart(3, '0'));
  });
  nextDashakamBtn.addEventListener('click', () => {
    if (currentDashakam < totalDashakams) loadDashakam(String(currentDashakam + 1).padStart(3, '0'));
  });

  /*** Repeat toggles ***/
  repeatVerseBtn.addEventListener('click', () => {
    repeatVerse = !repeatVerse;
    repeatVerseBtn.classList.toggle('active', repeatVerse);
  });
  repeatDashakamBtn.addEventListener('click', () => {
    repeatDashakam = !repeatDashakam;
    repeatDashakamBtn.classList.toggle('active', repeatDashakam);
  });

  /*** Play/pause icon management (also handled by audio events) ***/
  playPauseBtn.addEventListener('click', () => {
    if (audio.paused) audio.play().catch(()=>{});
    else audio.pause();
  });
  audio.addEventListener('play', () => playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>');
  audio.addEventListener('pause', () => playPauseBtn.innerHTML = '<i class="fas fa-play"></i>');

  /*** Speed / Mute ***/
  speedBtn.addEventListener('click', () => {
    speedIndex = (speedIndex + 1) % speedOptions.length;
    audio.playbackRate = speedOptions[speedIndex];
    const label = speedOptions[speedIndex] + '×';
    speedBtn.textContent = label;
    clearTimeout(speedTimeout);
    speedTimeout = setTimeout(() => { speedBtn.innerHTML = '<i class="fas fa-tachometer-alt"></i>'; }, 900);
  });

  muteBtn.addEventListener('click', () => {
    audio.muted = !audio.muted;
    muteBtn.innerHTML = audio.muted ? '<i class="fas fa-volume-mute"></i>' : '<i class="fas fa-volume-up"></i>';
  });

  /*** Time formatting / display (periodic refresh) ***/
  function formatTime(s) {
    if (!s || isNaN(s)) return '00:00';
    const m = Math.floor(s/60).toString().padStart(2,'0');
    const sec = Math.floor(s%60).toString().padStart(2,'0');
    return `${m}:${sec}`;
  }

  function updateTimeDisplay() {
    const elapsed = audio.currentTime || 0;
    const duration = (audio.duration && !isNaN(audio.duration)) ? audio.duration : estimatedDashakamDuration;
    const remaining = Math.max(0, duration - elapsed);
    timeDisplay.textContent = `Elapsed: ${formatTime(elapsed)} | Remaining: ${formatTime(remaining)}`;
  }
  setInterval(updateTimeDisplay, 1000);
  audio.addEventListener('timeupdate', updateTimeDisplay);

  /*** Go-to toggle simple handlers ***/
  let gotoOpen = false;
  function openGoto(open) { gotoOpen = open; if (gotoPanel) gotoPanel.style.display = open ? 'block' : 'none'; if (gotoToggle) gotoToggle.textContent = open ? 'Go to ▴' : 'Go to ▾'; }
  if (gotoToggle) { gotoToggle.addEventListener('click', () => openGoto(!gotoOpen)); }

  /*** Transliteration toggle ***/
  if (translitToggle) {
    translitToggle.addEventListener('click', () => {
      showTranslit = !showTranslit;
      translitToggle.textContent = showTranslit ? 'Devanagari' : 'English Transliteration';
      if (currentCueIndex !== -1 && cues[currentCueIndex]) {
        const parsed = parseCueText(cues[currentCueIndex].text);
        verseDiv.innerHTML = nl2br(showTranslit ? parsed.verseTrans : parsed.verseDev);
        splitWordsDiv.innerHTML = nl2br(showTranslit ? parsed.splitTrans : parsed.splitDev);
        meaningDiv.innerHTML = nl2br(parsed.meaning || '');
      }
    });
  }

  /*** Audio ended handling: auto-next dashakam ***/
  audio.addEventListener('ended', async () => {
    console.log('audio ended event, currentCueIndex=', currentCueIndex);
    if (cues && currentCueIndex >= cues.length - 1) {
      if (currentDashakam < totalDashakams) {
        const nextD = String(currentDashakam + 1).padStart(3, '0');
        await loadDashakam(nextD, true);
        if (cues.length > 0) jumpToCue(0, true);
      } else if (repeatDashakam && cues.length > 0) {
        jumpToCue(0, true);
      } else {
        // stop at end
        audio.pause();
        currentCueIndex = -1;
        updateCurrentInfo();
      }
    }
  });

  /*** Build UI and initial load ***/
  buildGroupGrid();
  loadDashakam('001').catch(e => console.error('initial loadDashakam error', e));
});
</script>
</body>
</html>
